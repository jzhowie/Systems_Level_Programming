Variables & Control Structures
	0 is false, everything else is true
	Delclaring a variable means requesting bits of memory from the system
	Initialize variables outside of a for loop
		if (x = 0) x is assigned 0, assignment operator returns 0, the if statement will always fail
	Declare functions before they are used Ex: double dylan(int jack);
		Or you write it on top

Compiling
	Preprocessor
		Text replacement program
		Preprocessor commands start with a #
			No ";" at the end
			#include - adds entire text of included file
			#define <arg1> <arg2> - replaces every instance of arg1 with arg2
				You can also define function-like stuff:
				#define MAX(a, b) a > b ? a : b
			#ifndef <IDENTIFIER> ... #endif - If identifier is not defined for preprocessor, read up to #endif, else don't.
				Example:
				#ifndef PI
				#define PI 3.14
				#endif
	Compiler
		Code -> binary code
		Doesn't create an executable
		Only one C file at a time
		gcc -c runs preprocessor and compiler
		gcc -E runs through preprocessor
	Linker
		Combines binary files into an executable
		Automatically searches for standard library source code
		If multiple definitions for identifies are found, the linker will fail
		Exactly one definition for main
		Gcc compiles each file then links then together
			Giving gcc .o files will skip the compilation step
	Make
		Compiling tool
		make will look for a file makefile
			Targets: Things to make (executables)
			Dependencies: Files/other targets needed to make a target
			Rules: How to create the target
		Make will always run the first target
		Make recursively checks dependencies (depth-first)
		Checks modify timestamps and only runs rules if target is older than dependencies
		Syntax:
			target: dependency0 dependency1 ...
			TAB rule

			Other make targets: run, clean, <target file>
			./make <run, clean, file>

Memory
	Binary: A 0 or 1 is a bit, 8 bits = 1 byte
	Volatile, requires power to store data
	Opening a file: Computer copies file from storage into memory
		Saving does the reverse
		Running programs use memory (declaring variables)

	Endianness
		Significance of bytes
		261 as an int would be stored as 00000000 00000000 00000001 00000101
			Big endian - most significant byte is at the start
				Print as a short would not include the last two bytes
			Little endian is the opposite (00000101 00000001 00000000 00000000)
				Print would include the full value

Memory Addresses
	Identifier - variable name
	Value - variable data
	Address - location of data in memory
		Addressed from first byte up
		Potential memory addresses is a processor limitation
			A 32-bit processor can only process no more than 32 bits at once
		OS defines address space
		You can get the address of any variable using the address of operator: &
		%p prints out memory address in hexadecimal format
			You can also see it as an unsigned long
		%u(nsigned), %d(ecimal), %o(ctal), (he)%x(adecimal)
			h will print 2 bytes
			hh will print 1 byte

	Pointers
		Pointers are variables that store memory addresses
			Unsigned
			8 bytes long on 64-bit systems
			Declaration:
				int *p = &x;
			In Java NullPointerExceptions come from when object pointers point to memory address 0
		Pointer Arithmetic
			Can add or subtract
			Scales by the size of type (char increments by 1, int increments by 4)
			*cp++ != (*cp)++
			Pointers can store memory addresses out of the physical limit, but won't be able to dereference (Seg Fault)
		Arrays
			Block of memory that holds multiple pieces of the same data type
			C arrays have no length attribute
			Size of an array is set at declaration (cannot be dynamic, equal to a variable or function)
			No boundary checking
			Declaration:
				float ray[5];
				ray[2] = 8.22;

				Requests enough memory for 5 floats

			Array Variables
				Pointers to the allocated array block
				Immutable
				Ray will point to the beginning of the array
				sizeof(variable) can give the size of a variable
				You can keep track of array size like this:
					int ARR_SIZE = 10;
					float arr[ARR_SIZE];
				Normal pointers can also be assigned to array pointers (it will do normal pointer things)

				If you did float *rp = ray;
				sizeof(rp) would return 20, sizeof(ray) would return 8

					float ray[5];
					float *rp = &ray;
					Then:
						ray[3] = rp[3] = *(ray + 3) = *(rp + 3) = 3[rp]
C functions
	Pass by value
	When a function is called, arguments are copied to new variables
	Pointers can be passed as arguments
	When you pass an array as an argument, it is treated as a memory address, not an array
		void arr_func(int arr[]);
		void point_func(int *arr); // preferable because passing an array would be treated as a pointer
