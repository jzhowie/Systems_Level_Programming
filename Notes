Variables & Control Structures
	0 is false, everything else is true
	Declaring a variable means requesting memory from the system
	Declare functions before they are used Ex: double dylan(int jack);

Compiling
	Preprocessor
		Text replacement program
		Preprocessor commands start with a #
			No ";" at the end
			#include - adds entire text of included file
			#define <arg1> <arg2> - replaces every instance of arg1 with arg2
				You can also define function-like stuff:
				#define MAX(a, b) a > b ? a : b
			#ifndef <IDENTIFIER> ... #endif - If identifier is not defined for preprocessor, read up to #endif, else don't.
				Example:
				#ifndef PI
				#define PI 3.14
				#endif
	Compiler
		Code -> binary code
		Doesn't create an executable
		Only one C file at a time
		gcc -c runs preprocessor and compiler
		gcc -E runs through preprocessor
	Linker
		Combines binary files into an executable
		Automatically searches for standard library source code
		If multiple definitions for identifiers are found, the linker will fail
		Only one main function
		Gcc compiles each file then links them together
			Giving gcc .o files will skip the compilation step
	Make
		Compiling tool
		make will look for a file makefile
			Targets: Things to make (executables)
			Dependencies: Files/other targets needed to make a target
			Rules: Command to create target
		Make will always run the first target
		Make recursively checks dependencies
		Syntax:
			target: dependency0 dependency1 ...
			TAB rule

			Other make targets: run, clean, <target file>
			make <run, clean, file>

Memory
	Binary: A 0 or 1 is a bit, 8 bits = 1 byte
	Volatile, requires power to store data
	Opening a file: Computer copies file from storage into memory
		Saving does the reverse
		Running programs use memory (declaring variables)

	Endianness
		Significance of bytes
		261 as an int would be stored as 00000000 00000000 00000001 00000101
			Big endian - most significant byte is at the start
				Print as a short would not include the last two bytes
			Little endian is the opposite (00000101 00000001 00000000 00000000)
				Print would include the full value

Memory Addresses
	Identifier - variable name
	Value - variable data
	Address - location of data in memory
		Addressed from first byte up
		Potential memory addresses is a processor limitation
			A 32-bit processor can only process no more than 32 bits at once
		OS defines address space
		You can get the address of any variable using the address of operator: &
		%p prints out memory address in hexadecimal format
			You can also see it as an unsigned long
		%u(nsigned), %d(ecimal), %o(ctal), (he)%x(adecimal)
			h will print 2 bytes
			hh will print 1 byte

	Pointers
		Pointers are variables that store memory addresses
			Unsigned
			8 bytes long on 64-bit systems
			Declaration:
				int *p = &x;
			In Java NullPointerExceptions come from when object pointers point to memory address 0
		Pointer Arithmetic
			Can add or subtract
			Scales by the size of type (char increments by 1, int increments by 4)
			*cp++ != (*cp)++
			Pointers can store memory addresses outside the physical limit, but won't be able to dereference (Seg Fault)
		Arrays
			Block of memory that holds multiple pieces of the same data type
			C arrays have no length attribute
			Size of an array is set at declaration (cannot be dynamic)
			No boundary checking
			Declaration:
				float ray[5];
				ray[2] = 8.22;
				Requests enough memory for 5 floats

			Array Variables
				Immutable pointer to the beginning of the allocated array block
				sizeof(variable) can give the size of a variable
				You can keep track of array size like this:
					int ARR_SIZE = 10;
					float arr[ARR_SIZE];
				Normal pointers can also be assigned to array pointers (it will do normal pointer things)

				If you did float *rp = ray;
				sizeof(rp) would return 20, sizeof(ray) would return 8

					float ray[5];
					float *rp = &ray;
					Then:
						ray[3] = rp[3] = *(ray + 3) = *(rp + 3) = 3[rp]


C functions
	Pass by value
	When a function is called, arguments are copied to new variables
	Pointers can be passed as arguments
	When you pass an array as an argument, it is treated as a memory address, not an array
		void arr_func(int arr[]);
		void point_func(int *arr); // preferable because passing an array would be treated as a pointer

Strings
	Character array where the last entry in the array is NULL
		['h', 'e', 'l', 'l', 'o', 0]
	Creating a string literal makes a char array long enough to store the string + the terminating NULL
	String literals are immutable
	If a string literal is repeated in code, the original array is used
		80 "hello" strings will ALL point to one "hello"
	String declaration:
		char s[256]; Only declares a mutable array (no characters or NULL saved)
		char s[256] = "Imagine"; Creates string literal + copies literal + NULL into array (in this case it would be the first 8 bytes)
			You can go "out of bounds" in the array with a large enough string
		char s[] = "Tuesday";
			Creates string literal + creates 8 byte array (string length + NULL) + copies into array
		char *s = "Mankind";
			Creates string literal + s points to string... and that is it (do not do this)

		char s[10] = "Yankees";
		s = "Mets"; is an error
		s[0] = 'M'; is ok

		char *s = "AL East Champions";
		s = "The Best"; is ok
		s[0] = 'M'; is not

Structs
	Custom data type that is a collection of values
	Declaration:
		struct { int a; char x; } s;
		Anonymous struct
		Everything up to s is the type
		. operator accesses value inside struct
		s.a = 10;
		s.x = '@';
	Prototyping structs
		Declaration:
			struct foo { int a; char x; };
			struct foo becomes a valid type so you can declare variables with that type
			foo is not a variable name
		Assignment copies variables into struct
			Could be potentially memory-heavy
		Try to keep structs outside functions (mainly .h files)
	You can make a pointer to a struct
		Declaration:
			struct foo *p = &s;
			. happens before *
			(*p).a != *p.a
			Also p->x is syntactic shorthand for (*p).x
	The value of a struct != The address of a struct (unlike an array variable)

Stack memory
	Stack stores all normally declared variables
	Functions are pushed onto the stack in the order they are called
	When a function is popped off the stack, any memory associated is released
Heap memory
	Heap memory stores dynamically allocated memory
	Data remains in the heap until it is manually released or the program ends
	malloc (size_t x)
	Allocates x bytes of heap memory
		Returns the address at the beginning of the allocation (void pointer)
	free (void* p)
		Releases dynamically allocated memory
		P must point to the beginning of a dynamically allocated block of memory
		*Every* call to malloc/calloc should have a corresponding call to free
	calloc(size_t n, size_t x)
		Allocates n * x bytes of memory and ensures every bit is 0
	realloc(void *p, size_t x)
		Changes the amount of memory allocated for a block to x bytes
		P must point to the beginning of a block
		Returns a pointer to the beginning of the block (could move entire thing), if x is smaller than the original size, the extra bytes are released
2D arrays
	int b[2][4]; -> 2 * 4 * 4 bytes = 32 bytes
	int **bp = b; -> Pointer scaling is inaccurate
	int (*bp1)[4] = b; -> Pointer scaling is accurate
	void foo(int a[2][4]);
	void foo(int (*a)[4]);
	void foo(int a[][4]);
	Alternatively you can work in heap memory
	int **bp = malloc(2 * sizeof(int *));
	bp[i] = malloc(4 * sizeof(int));
Bits
	You can declare ints as a binary, octal, or hexadecimal
	0b1101 == 015 == 0xD == 13
Bitwise Operators
	Evaluated on every bit of a value
	~x
		Negation
		"Flip" every bit of x
	a | b
		Bitwise or																									0011			0011			1101
		Perform logical or for each pair of bits in (a, b)				|	1001		&	1001		^	1011
	a & b																													1011			0001			0110
		Bitwise and
		Bitwise or but and
	a ^ b
		Bitwise xor
		Bitwise or but xor
